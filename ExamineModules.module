<?php

/**
 * Hooks into ProcessDiagnostics to add additional module version related information.
 */
class ExamineModules extends Process
{
    public static function getModuleInfo()
    {
        return array(
            'title'     => __('Module version checking', __FILE__),
            'summary'   => __('Allows collection of module version diagnostics', __FILE__),
            'version'   => 1,
            'permanent' => false,
            'autoload'  => true,
            'singular'  => true,
            'requires'  => 'ProcessDiagnostics',
            'author'    => 'Nico Knoll',
        );
    }


    public function init()
    {
        parent::init();

        $this->addHookAfter('ProcessDiagnostics::collectDiagnostics', $this, 'AppendDiagnostics');
    }


    /**
     * Returns a diagnostic array about installed modules and looks for updates
     */
    public function GetDiagnostics()
    {
        $defaultServiceUrl = 'http://modules.processwire.com/export-json/';
        $defaultServiceKey = 'pw231';

        $modulesRemoteVersions = (array)$this->session->get('ModulesRemoteVersions');


        foreach($this->modules as $module) {

            $moduleInfo = wire('modules')->getModuleInfo($module->className());
            $localVersion = $this->formatVersion($moduleInfo['version']);

            // check if core module
            $core = false;
            $pathParts = explode('/', str_replace($this->config->urls->root, '', $this->config->urls->{$module->className()}), 2);
            if($pathParts[0] == 'wire') {
                $core = true;
            }

            // only show installes /site/ modules
            if($core == false) {
                // if remote ersion is in session use this one otherwise load remote version from ... remote.
                if(!in_array($module->className(), array_keys($modulesRemoteVersions))) {

                    $url = trim($defaultServiceUrl, '/') . "/".$module->className()."/?apikey=" . $defaultServiceKey;

                    $http = new WireHttp();
                    $data = json_decode($http->get($url));

                    if($data->status != 'error') {
                        $remoteVersion = $this->formatVersion($data->module_version);
                        $modulesRemoteVersions[$module->className()] = $remoteVersion;
                    } else {
                        $modulesRemoteVersions[$module->className()] = $localVersion;
                    }
                }


                $updatable = ($modulesRemoteVersions[$module->className()] > $localVersion);
                $updateUrl = $this->config->urls->admin.'module/?update='.$module->className();

                $results[] = array(
                    'title'  => $moduleInfo['title'].' ('.$module->className().')',
                    'value'  => $updatable ? $this->_('Update available') :
                                             $this->_('Up to date'),
                    'status' => $updatable ? ProcessDiagnostics::$warn : ProcessDiagnostics::$ok,
                    'action' => $updatable ? sprintf($this->_('There is a new version available. <a href="%s">Click here to go to update page.</a>'), $updateUrl) : '',
                );
            }
        }

        $this->session->set('ModulesRemoteVersions', $modulesRemoteVersions);

        return $results;
    }


    protected function formatVersion($version)
    {
        return preg_replace('/(\d)(?=\d)/', '$1.', str_pad( (string)$version, 3, '0', STR_PAD_LEFT));
    }


    public function AppendDiagnostics($event)
    {
        $results = $event->return;
        $results[$this->_('Module Version Diagnostics')] = $this->GetDiagnostics();
        $event->return = $results;
    }
}
