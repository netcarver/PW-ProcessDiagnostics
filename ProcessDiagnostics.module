<?php

/**
 * A simple diagnostics module for ProcessWire.
 *
 * Inspired by the diagnostics tab in Textpattern.
 */
class ProcessDiagnostics extends Process
{
    protected static $ok;
    protected static $fail;
    protected static $warn;

    public static function getModuleInfo()
    {
        return array(
            'title'     => __('Diagnostics Page', __FILE__),
            'summary'   => __('Allows evaluation of run-time environment and detection of changes.', __FILE__),
            'version'   => 3,
            'permanent' => false,
            'autoload'  => true,
            'singular'  => true,
            'author'    => 'Stephen Dickinson, QBox',
        );
    }


    public function init()
    {
        parent::init();

        $this->server_software = '';
        if (isset($_SERVER['SERVER_SOFTWARE'])) {
            $this->server_software = $_SERVER['SERVER_SOFTWARE'];
        } else if (isset($_SERVER['HTTP_HOST'])) {
            $this->server_software = $_SERVER['HTTP_HOST'];
        }

        $this->is_apache = (($this->server_software && stristr($this->server_software, 'apache')) || is_callable('apache_get_version'));

        self::$ok   = $this->_('OK');
        self::$fail = $this->_('Failure');
        self::$warn = $this->_('Warning');
    }


    /**
     * Returns a diagnostic array about the current version of PHP and how that ties in with the version needed by PW.
     *
     * TODO: Have PW define it's required PHP version in the core, not just the installer.
     */
    protected function getPHPDiagnostics()
    {
        $fail_limit = '5.3.8';

        $status = self::$ok;
        $action = '';
        if (version_compare(PHP_VERSION, $fail_limit) < 0) {
            $status = $this->_('Fail');
            $action = $this->_("Upgrade your PHP installation to at least version ").$fail_limit;
        }

        $results[] = array(
            'title'  => $this->_('PHP Version'),
            'value'  => PHP_VERSION,
            'status' => $status,
            'action' => $action,
        );

        return $results;
    }


    /**
     * Returns a diagnostic array about the current time settings.
     */
    protected function getTimeDiagnostics()
    {
        $results[] = array(
            'title'  => $this->_('Timezone'),
            'value'  => $this->wire->config->timezone,
            'status' => self::$ok,
            'action' => '',
        );

        return $results;
    }


    /**
     * Reads basic FS parameters for the given file or directory.
     */
    protected function getFileSystemAttribs($name, $pathspec)
    {
        $fs_info = array(
            'name'   => $name,
            'path'   => $pathspec,
            'exists' => file_exists($pathspec),
            'isfile' => false,
            'islink' => false,
            'isdir'  => false,
            'read'   => false,
            'write'  => false,
            'exec'   => false,
            'perms'  => false,
        );

        if ($fs_info['exists']) {
            $fs_info['isfile'] = is_file($pathspec);
            $fs_info['islink'] = is_link($pathspec);
            $fs_info['isdir']  = is_dir($pathspec);
            $fs_info['read']   = is_readable($pathspec);
            $fs_info['write']  = is_writable($pathspec);
            $fs_info['exec']   = is_executable($pathspec);
            $fs_info['perms']  = fileperms($pathspec);
        }

        return $fs_info;
    }


    /**
     * Creates a text description from the given file information.
     */
    public function describeFSInfo($info)
    {
        $out = array();

        if ($info['exists']) {
            $out[] = $this->_('Exists');

            if ($info['read']) {
                $out[] = $this->_('is readable');
            } else {
                $out[] = $this->_('is not readable');
            }

            if ($info['write']) {
                $out[] = $this->_('is writable');
            } else {
                $out[] = $this->_('is not writable');
            }

            $out[] = substr(sprintf('%o', $info['perms']), -4);
        } else {
            $out[] = $this->_('Does not exist.');
        }

        return implode(', ', $out);
    }


    /**
     * Returns a diagnostic array about the webserver.
     *
     * For Apache, this also checks if the .htaccess file is in the right place and is readable by the webserver.
     */
    protected function getWebserverDiagnostics()
    {
        $results[] = array(
            'title'  => $this->_('Webserver'),
            'value'  => $this->server_software,
            'status' => self::$ok,
            'action' => '',
        );

        if ($this->is_apache) {
            if (is_callable('apache_get_modules')) {
                $apache_modules = apache_get_modules();

                $rewrite_ok = in_array('mod_rewrite', $apache_modules);
                $results[] = array(
                    'title'  => $this->_('Apache mod_rewrite'),
                    'value'  => $rewrite_ok ? $this->_('Installed') : $this->_('Not installed'),
                    'status' => $rewrite_ok ? self::$ok : $this->_('Fail'),
                    'action' => $rewrite_ok ? '' : $this->_('Install mod_rewrite, it\'s currently not available to Apache.'),
                );
            }

            $ht_info = $this->getFileSystemAttribs('.htaccess', $this->wire->config->paths->root.'/.htaccess');
            $httext_info = $this->getFileSystemAttribs('htaccess.txt', $this->wire->config->paths->root.'/htaccess.txt');

            $htaccess_ok  = ($ht_info['exists'] && $ht_info['read'] && !$ht_info['write']);
            $ht_mv_needed = $httext_info['exists'] && !$ht_info['exists'];

            // Diagnostics for the htaccess.txt file...
            $results[] = array(
                'title'  => 'htaccess.txt',
                'value'  => $this->describeFSInfo($httext_info),
                'status' => ($ht_mv_needed || $httext_info['exists']) ? $this->_('Fail') : self::$ok,
                'action' => $ht_mv_needed ? 'Rename htaccess.txt to .htaccess' : $httext_info['exists'] ? $this->_('Delete htaccess.txt') : '',
            );

            // Diagnostics for the .htaccess file...
            $results[] = array(
                'title'  => $this->_('.htaccess file'),
                'value'  => $this->describeFSInfo($ht_info),
                'status' => $htaccess_ok ? self::$ok : $this->_('Fail'),
                'action' => $htaccess_ok ? '' : $this->_('.htaccess must exist, must be readable, must <strong>not</strong> be writable.'),
            );


        }

        return $results;
    }


    /**
     * TODO extend these checks to cover other users in the system, not just the webserver user. For example, if a dir
     * is 777 it's probably too wide open and at least needs a warning generated.
     */
    protected function getFilesystemDiagnostics()
    {

        $root_info   = $this->getFileSystemAttribs($this->_('Root directory'),    $this->wire->config->paths->root);
        //$admin_info  = $this->getFileSystemAttribs($this->_('Admin directory'),   $this->wire->config->paths->admin);
        $asset_info  = $this->getFileSystemAttribs($this->_('Assets directory'),  $this->wire->config->paths->assets);
        $cache_info  = $this->getFileSystemAttribs($this->_('Cache directory'),   $this->wire->config->paths->cache);
        $sess_info   = $this->getFileSystemAttribs($this->_('Session directory'), $this->wire->config->paths->sessions);

        $root_ok     =  $root_info['exists']  &&  $root_info['read']  && !$root_info['write'];
        //$admin_ok    =  $admin_info['exists'] &&  $admin_info['read'] && !$admin_info['write'];
        $assets_ok   =  $asset_info['exists'] &&  $asset_info['read'] &&  $asset_info['write'];
        $cache_ok    =  $cache_info['exists'] &&  $cache_info['read'] &&  $cache_info['write'];
        $sessions_ok =  $sess_info['exists']  &&  $sess_info['read']  &&  $sess_info['write'];

        $results[] = array(
            'title'  => $root_info['name'],
            'value'  => $this->describeFSInfo($root_info),
            'status' => ($root_ok) ? self::$ok : $this->_('Fail'),
            'action' => ($root_ok) ? '' : $this->_('Folder should not be writable for webserver user.'),
        );

        //$results[] = array(
        //    'title'  => $admin_info['name'],
        //    'value'  => $this->describeFSInfo($admin_info),
        //    'status' => ($admin_ok) ? self::$ok : $this->_('Fail'),
        //    'action' => ($admin_ok) ? '' : $this->_('Folder should not be writable for webserver user.'),
        //);

        $results[] = array(
            'title'  => $asset_info['name'],
            'value'  => $this->describeFSInfo($asset_info),
            'status' => ($assets_ok) ? self::$ok : $this->_('Fail'),
            'action' => ($assets_ok) ? '' : $this->_('Folder should be writable for webserver user.'),
        );

        $results[] = array(
            'title'  => $cache_info['name'],
            'value'  => $this->describeFSInfo($cache_info),
            'status' => ($cache_ok) ? self::$ok : $this->_('Fail'),
            'action' => ($cache_ok) ? '' : $this->_('Folder should be writable for webserver user.'),
        );

        $results[] = array(
            'title'  => $sess_info['name'],
            'value'  => $this->describeFSInfo($sess_info),
            'status' => ($sessions_ok) ? self::$ok : $this->_('Fail'),
            'action' => ($sessions_ok) ? '' : $this->_('Folder should be writable for webserver user.'),
        );


        return $results;
    }



    /**
     * To extend the collected information, just add a new method call to the list of arrays in this array merge.
     * Each method must return an array of results (numerically keyed) and each result will be an array with four string
     * keys... 'title', 'value', 'status' and 'action'.
     */
    public function ___collectDiagnostics()
    {
        $results = array_merge_recursive(
            $this->getPHPDiagnostics(),
            $this->getWebserverDiagnostics(),
            $this->getFilesystemDiagnostics(),
            $this->getTimeDiagnostics()
        );

        return $results;
    }


    public function ___execute()
    {
        $this->setFuel('processHeadline', $this->_('System Diagnostics'));

        $description = "<p class='description'>". $this->_("Results of scanning your system...") . "</p>";

        $results = $this->collectDiagnostics();

        $table = $this->modules->get("MarkupAdminDataTable");
        $table->setEncodeEntities(false);
        $table->headerRow(array($this->_('Attribute'), $this->_('Value'), $this->_('Status'), $this->_('Remedial Actions / Notes')));

        foreach ($results as $k => $row) {
            $table->row(array(
                $row['title'],
                $row['value'],
                (self::$ok === $row['status']) ? '<div class="status">' . $row['status'] . '</div>' : '<div class="status fail">' . $row['status'] . '</div>',
                $row['action'],
            ));
        }


        return $description . $table->render();
    }


    public function ___install()
    {
        parent::install();

        $p = new Page();
        $p->template = $this->templates->get("admin");
        $p->parent = $this->pages->get("template=admin, name=setup");
        $p->title = $this->_('Diagnostics');
        $p->name  = __CLASS__;
        $p->process = $this;
        $p->save();
    }


    public function ___uninstall()
    {
        $p = $this->pages->get('template=admin, name=' . __CLASS__);
        $p->delete();
    }
}

// eof
