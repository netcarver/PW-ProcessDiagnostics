<?php

/**
 * A simple diagnostics module for ProcessWire.
 *
 * Inspired by the diagnostics tab in Textpattern.
 */
class ProcessDiagnostics extends Process
{
    public static $ok;
    public static $fail;
    public static $warn;

    public static $verbosity;

    const LOW_VERBOSITY    = 1;
    const MEDIUM_VERBOSITY = 2;
    const HIGH_VERBOSITY   = 4;

    public static function getModuleInfo()
    {
        return array(
            'title'     => __('Diagnostics Page', __FILE__),
            'summary'   => __('Allows evaluation of run-time environment and detection of changes.', __FILE__),
            'version'   => 4,
            'permanent' => false,
            'autoload'  => true,
            'singular'  => true,
            'author'    => 'Stephen Dickinson, QBox',
        );
    }


    public function init()
    {
        parent::init();

        $this->server_software = '';
        if (isset($_SERVER['SERVER_SOFTWARE'])) {
            $this->server_software = $_SERVER['SERVER_SOFTWARE'];
        } else if (isset($_SERVER['HTTP_HOST'])) {
            $this->server_software = $_SERVER['HTTP_HOST'];
        }

        $this->is_apache = (($this->server_software && stristr($this->server_software, 'apache')) || is_callable('apache_get_version'));

        self::$ok   = $this->_('OK');
        self::$fail = $this->_('Failure');
        self::$warn = $this->_('Warning');

        self::$verbosity = self::HIGH_VERBOSITY;
    }


    /**
     * Returns a diagnostic array about the current version of PHP and how that ties in with the version needed by PW.
     *
     * TODO: Have PW define it's required PHP version in the core, not just the installer.
     */
    protected function getPHPDiagnostics()
    {
        $fail_limit = '5.3.8';

        $status = self::$ok;
        $action = '';
        if (version_compare(PHP_VERSION, $fail_limit) < 0) {
            $status = self::$fail;
            $action = $this->_("Upgrade your PHP installation to at least version ").$fail_limit;
        }

        $results[] = array(
            'title'  => $this->_('Version'),
            'value'  => PHP_VERSION,
            'status' => $status,
            'action' => $action,
        );

        $mem = trim(ini_get('memory_limit'));
        $results[] = array(
            'title'  => $this->_('Max Memory'),
            'value'  => $mem,
            'status' => self::$ok,
            'action' => ''
        );

        $api     = null;   // string  full api info
        $sys     = null;   // string  full sys info

        ob_start();
        phpinfo(INFO_GENERAL);
        $buffer = str_replace("\r\n", "\n", ob_get_contents());
        ob_end_clean();

        $ver = phpversion();

        $mem = trim(ini_get('memory_limit'));

        $pattern = preg_match('#</td>#msi', $buffer)===1 ? '#>Server API.*?</td><td.*?>(.*?)</td>#msi' : '#\nServer API.*?=>(.*?)\n#msi';
        $api = preg_match($pattern, $buffer, $matches)===1 ? trim($matches[1]) : null;

        $pattern = preg_match('#</td>#msi', $buffer)===1 ? '#>System.*?</td><td.*?>(.*?)</td>#msi' : '#\nSystem.*?=>(.*?)\n#msi';
        $sys = preg_match($pattern, $buffer, $matches)===1 ? trim($matches[1]) : null;


        // build results array PHP Handler
        $results[] = array(
            'title'  => $this->_('Handler'),
            'value'  => $api,
            'status' => self::$ok,
            'action' => '',
        );


        // build results array PHP system info
        $results[] = array(
            'title'  => $this->_('System Information'),
            'value'  => $sys,
            'status' => self::$ok,
            'action' => '',
        );

        return $results;
    }


    /**
     * Returns a diagnostic array about the current time settings.
     */
    protected function getTimeDiagnostics()
    {
        $results[] = array(
            'title'  => $this->_('Timezone'),
            'value'  => $this->wire->config->timezone,
            'status' => self::$ok,
            'action' => '',
        );

        return $results;
    }


    /**
     * Reads basic FS parameters for the given file or directory.
     */
    protected function getFileSystemAttribs($name, $pathspec)
    {
        $fs_info = array(
            'name'   => $name,
            'path'   => $pathspec,
            'exists' => file_exists($pathspec),
            'isfile' => false,
            'islink' => false,
            'isdir'  => false,
            'read'   => false,
            'write'  => false,
            'exec'   => false,
            'perms'  => false,
        );

        if ($fs_info['exists']) {
            $fs_info['isfile'] = is_file($pathspec);
            $fs_info['islink'] = is_link($pathspec);
            $fs_info['isdir']  = is_dir($pathspec);
            $fs_info['read']   = is_readable($pathspec);
            $fs_info['write']  = is_writable($pathspec);
            $fs_info['exec']   = is_executable($pathspec);
            $fs_info['perms']  = fileperms($pathspec);
        }

        return $fs_info;
    }


    /**
     * Creates a text description from the given file information.
     */
    public function describeFSInfo($info)
    {
        $out = array();

        if ($info['exists']) {
            $out[] = $this->_('Exists');

            if ($info['read']) {
                $out[] = $this->_('is readable');
            } else {
                $out[] = $this->_('is not readable');
            }

            if ($info['write']) {
                $out[] = $this->_('is writable');
            } else {
                $out[] = $this->_('is not writable');
            }

            $out[] = substr(sprintf('%o', $info['perms']), -4);
        } else {
            $out[] = $this->_('Does not exist.');
        }

        return implode(', ', $out);
    }


    /**
     * Returns a diagnostic array about the webserver.
     *
     * For Apache, this also checks if the .htaccess file is in the right place and is readable by the webserver.
     */
    protected function getWebserverDiagnostics()
    {
        $results[] = array(
            'title'  => $this->_('Webserver'),
            'value'  => $this->server_software,
            'status' => self::$ok,
            'action' => '',
        );

        if ($this->is_apache) {
            if (is_callable('apache_get_modules')) {
                $apache_modules = apache_get_modules();

                $rewrite_ok = in_array('mod_rewrite', $apache_modules);
                $results[] = array(
                    'title'  => $this->_('Apache mod_rewrite'),
                    'value'  => $rewrite_ok ? $this->_('Installed') :
                                              $this->_('Not installed'),
                    'status' => $rewrite_ok ? self::$ok : self::$fail,
                    'action' => $rewrite_ok ? '' : $this->_('Install mod_rewrite, it\'s currently not available to Apache.'),
                );
            }

            $ht_info = $this->getFileSystemAttribs('.htaccess', $this->wire->config->paths->root.'/.htaccess');
            $httext_info = $this->getFileSystemAttribs('htaccess.txt', $this->wire->config->paths->root.'/htaccess.txt');

            $ht_ok        = $ht_info['exists'] && $ht_info['read'];
            $ht_write     = $ht_info['write'];
            $ht_status    = self::$fail;
            if ($ht_ok) {
                if ($ht_write) {
                    $ht_status = self::$warn;
                } else {
                    $ht_status = self::$ok;
                }
            }
            $ht_mv_needed = $httext_info['exists'] && !$ht_info['exists'];

            if ($httext_info['exists']) {
                // Diagnostics for the htaccess.txt file...
                $results[] = array(
                    'title'  => 'htaccess.txt',
                    'value'  => $this->describeFSInfo($httext_info),
                    'status' => ($ht_mv_needed || $httext_info['exists']) ? self::$fail : self::$ok,
                    'action' => $ht_mv_needed ? $this->_('Rename htaccess.txt to .htaccess') :
                    $httext_info['exists'] ? $this->_('Delete htaccess.txt') : '',
                    );
            }

            // Diagnostics for the .htaccess file...
            $results[] = array(
                'title'  => $this->_('.htaccess file'),
                'value'  => $this->describeFSInfo($ht_info),
                'status' => $ht_status,
                'action' => $ht_ok && !$ht_write ? '' : $this->_('.htaccess must exist, must be readable, should <strong>not</strong> be writable.'),
            );
        }

        return $results;
    }


    /**
     * TODO extend these checks to cover other users in the system, not just the webserver user. For example, if a dir
     * is 777 it's probably too wide open and at least needs a warning generated.
     */
    protected function getFilesystemDiagnostics()
    {
        $install_file = $this->getFileSystemAttribs($this->_('Installation file'),        $this->wire->config->paths->root.'/install.php');
        $install_dir  = $this->getFileSystemAttribs($this->_('Installation directory'),   $this->wire->config->paths->root.'/site/install/');
        $site_def_dir = $this->getFileSystemAttribs($this->_('/site-default/ directory'), $this->wire->config->paths->root.'/site-default/');

        $root_info    = $this->getFileSystemAttribs($this->_('Root directory'),    $this->wire->config->paths->root);
        $asset_info   = $this->getFileSystemAttribs($this->_('Assets directory'),  $this->wire->config->paths->assets);
        $cache_info   = $this->getFileSystemAttribs($this->_('Cache directory'),   $this->wire->config->paths->cache);
        $sess_info    = $this->getFileSystemAttribs($this->_('Session directory'), $this->wire->config->paths->sessions);
        $site_info    = $this->getFileSystemAttribs($this->_('Site directory'),    $this->wire->config->paths->site);

        $inst_file_ok = !$install_file['exists'];
        $inst_dir_ok  = !$install_dir['exists'];
        $root_ok      =  $root_info['exists']  &&  $root_info['read']  && !$root_info['write'];
        $assets_ok    =  $asset_info['exists'] &&  $asset_info['read'] &&  $asset_info['write'];
        $cache_ok     =  $cache_info['exists'] &&  $cache_info['read'] &&  $cache_info['write'];
        $sessions_ok  =  $sess_info['exists']  &&  $sess_info['read']  &&  $sess_info['write'];

        $results[] = array(
            'title'  => $root_info['name'],
            'value'  => $this->describeFSInfo($root_info),
            'status' => ($root_ok) ? self::$ok : self::$fail,
            'action' => ($root_ok) ? '' : $this->_('Folder should not be writable for webserver user.'),
        );

        $results[] = array(
            'title'  => $install_file['name'],
            'value'  => $this->describeFSInfo($install_file),
            'status' => ($inst_file_ok) ? self::$ok : self::$fail,
            'action' => ($inst_file_ok) ? '' : $this->_('Delete the file "install.php".'),
        );

        $results[] = array(
            'title'  => $install_dir['name'],
            'value'  => $this->describeFSInfo($install_dir),
            'status' => ($inst_dir_ok) ? self::$ok : self::$fail,
            'action' => ($inst_dir_ok) ? '' : $this->_('Delete the "/site/install/" directory.'),
        );

        if ($site_def_dir['exists']) {
            $results[] = array(
                'title'  => $site_def_dir['name'],
                'value'  => $this->describeFSInfo($site_def_dir),
                'status' => ($inst_dir_ok) ? self::$ok : self::$fail,
                'action' => ($inst_dir_ok) ? '' : (($site_info['exists']) ? $this->_('Delete the "/site-default/" directory.') :
                                                                            $this->_('Installation should have renamed "/site-default/" to "/site/".')),
                );
        }

        $site_ok = $site_info['exists'] && $site_info['read'] && !$site_info['write'];
        $results[] = array(
            'title'  => $site_info['name'],
            'value'  => $this->describeFSInfo($site_info),
            'status' => ($site_ok) ? self::$ok : self::$fail,
            'action' => ($site_ok) ? '' : $this->_('Folder should not be writable for webserver user.'),
        );

        $results[] = array(
            'title'  => $asset_info['name'],
            'value'  => $this->describeFSInfo($asset_info),
            'status' => ($assets_ok) ? self::$ok : self::$fail,
            'action' => ($assets_ok) ? '' : $this->_('Folder should be writable for webserver user.'),
        );

        $results[] = array(
            'title'  => $cache_info['name'],
            'value'  => $this->describeFSInfo($cache_info),
            'status' => ($cache_ok) ? self::$ok : self::$fail,
            'action' => ($cache_ok) ? '' : $this->_('Folder should be writable for webserver user.'),
        );

        $results[] = array(
            'title'  => $sess_info['name'],
            'value'  => $this->describeFSInfo($sess_info),
            'status' => ($sessions_ok) ? self::$ok : self::$fail,
            'action' => ($sessions_ok) ? '' : $this->_('Folder should be writable for webserver user.'),
        );


        return $results;
    }


    /**
     * Capitialise the initial character of the given string.
     */
    public static function initCap($string)
    {
        return strtoupper($string[0]) . substr($string, 1);
    }


    /**
     * To extend the collected information, just add a new method call to the list of arrays in this array merge.
     * Each method must return an array of results (numerically keyed) and each result will be an array with four string
     * keys... 'title', 'value', 'status' and 'action'.
     */
    public function ___collectDiagnostics()
    {
        $results = array(
            $this->_('PHP Diagnostics...')            => $this->getPHPDiagnostics(),
            $this->_('Webserver Diagnostics...')      => $this->getWebserverDiagnostics(),
            $this->_('Filesystem Diagnostics...')     => $this->getFilesystemDiagnostics(),
            $this->_('Date/Time Diagnostics...')      => $this->getTimeDiagnostics()
        );

        return $results;
    }


    /**
     * Applies the selected verbosity to filter out unwanted diagnostic results.
     */
    public function filterDiagnostics(array $results)
    {
        if (self::HIGH_VERBOSITY === self::$verbosity) {
            return $results;
        }

        $filtered = array();
        foreach ($results as $caption => &$section_results) {
            $section_filtered = array();
            foreach ($section_results as $k => $diagnosis) {
                $status = $diagnosis['status'];

                if (
                   ($status === self::$ok) ||
                   ($status === self::$warn && self::LOW_VERBOSITY === self::$verbosity)
                ) {
                    continue;
                }

                $section_filtered[] = $diagnosis;
            }

            if (count($section_filtered)) {
                $filtered[$caption] = $section_filtered;
            }
        }

        return $filtered;
    }

    public function ___execute()
    {
        $this->setFuel('processHeadline', $this->_('System Diagnostics'));

        $out = "<p class='description'>". $this->_("Results of scanning your system...") . "</p>";

        $results = $this->collectDiagnostics();

        /**
         * Apply verbosity rules to collected information...
         */
        $results = $this->filterDiagnostics($results);

        foreach ($results as $caption => $section_results) {

            $out .= "\n<table class='DiagnosticsTable'>";
            $out .= "\n<caption>" . htmlspecialchars($caption, ENT_QUOTES | ENT_HTML5, 'UTF-8') . "</caption>";
            $out .= "\n<thead><tr>";
            $out .= "\n<th class='title'>".$this->_('Attribute')."</th>";
            $out .= "\n<th class='value'>".$this->_('Value')."</th>";
            $out .= "\n<th class='status'>".$this->_('Status')."</th>";
            $out .= "\n<th class='action'>".$this->_('Notes / Corrective Actions')."</th>";
            $out .= "\n</tr></thead>";
            $out .= "\n<tbody>";

            foreach ($section_results as $k => $row) {
                $class = 'ok';
                switch ($row['status']) {
                case self::$fail :
                    $class = 'failure';
                    break;
                case self::$warn :
                    $class = 'warning';
                    break;
                default :
                    $class = 'ok';
                }

                $out .= "\n<tr>";
                $out .= "\n<td>" . $row['title'] . "</td>";
                $out .= "\n<td>" . $row['value'] . "</td>";
                $out .= "\n<td class='status'><div class='$class'>" . $row['status'] . "</div></td>";
                $out .= "\n<td>" . $row['action'] . "</td>";
                $out .= "\n</tr>";

            }
            $out .= "\n</tbody></table>";
        }
        return $out;
    }


    public function ___install()
    {
        $p = new Page();
        $p->template = $this->templates->get("admin");
        $p->parent = $this->pages->get("template=admin, name=setup");
        $p->title = $this->_('Diagnostics');
        $p->name  = __CLASS__;
        $p->process = $this;
        $p->save();
    }


    public function ___uninstall()
    {
        $p = $this->pages->get('template=admin, name=' . __CLASS__);
        if ($p->id > 0) {
            $p->delete();
        }
    }
}

// eof
