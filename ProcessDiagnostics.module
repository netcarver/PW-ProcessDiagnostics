<?php

/**
 * A simple diagnostics module for ProcessWire.
 *
 * Inspired by the diagnostics tab in Textpattern.
 */
class ProcessDiagnostics extends Process
{
    public static $ok;
    public static $fail;
    public static $warn;

    public static $verbosity;

    const LOW_VERBOSITY    = 1;
    const MEDIUM_VERBOSITY = 2;
    const HIGH_VERBOSITY   = 4;

    public static function getModuleInfo()
    {
        return array(
            'title'     => __('Diagnostics Page', __FILE__),
            'summary'   => __('Allows evaluation of run-time environment and detection of changes.', __FILE__),
            'version'   => 4,
            'permanent' => false,
            'autoload'  => true,
            'singular'  => true,
            'author'    => 'Stephen Dickinson, QBox',
        );
    }


    public function init()
    {
        parent::init();

        $this->server_software = '';
        if (isset($_SERVER['SERVER_SOFTWARE'])) {
            $this->server_software = $_SERVER['SERVER_SOFTWARE'];
        } else if (isset($_SERVER['HTTP_HOST'])) {
            $this->server_software = $_SERVER['HTTP_HOST'];
        }

        $this->is_apache = (($this->server_software && stristr($this->server_software, 'apache')) || is_callable('apache_get_version'));

        self::$ok   = $this->_('OK');
        self::$fail = $this->_('Failure');
        self::$warn = $this->_('Warning');
    }


    /**
     * Returns a diagnostic array about the current version of PHP and how that ties in with the version needed by PW.
     *
     * TODO: Have PW define it's required PHP version in the core, not just the installer.
     */
    protected function getPHPDiagnostics()
    {
        $fail_limit = '5.3.8';

        $status = self::$ok;
        $action = '';
        if (version_compare(PHP_VERSION, $fail_limit) < 0) {
            $status = self::$fail;
            $action = $this->_("Upgrade your PHP installation to at least version ").$fail_limit;
        }

        $results[] = array(
            'title'  => $this->_('Version'),
            'value'  => PHP_VERSION,
            'status' => $status,
            'action' => $action,
        );

        $mem = trim(ini_get('memory_limit'));
        $results[] = array(
            'title'  => $this->_('Max Memory'),
            'value'  => $mem,
            'status' => self::$ok,
            'action' => ''
        );

        $api     = null;   // string  full api info
        $sys     = null;   // string  full sys info

        ob_start();
        phpinfo(INFO_GENERAL);
        $buffer = str_replace("\r\n", "\n", ob_get_contents());
        ob_end_clean();

        $ver = phpversion();

        $mem = trim(ini_get('memory_limit'));

        $pattern = preg_match('#</td>#msi', $buffer)===1 ? '#>Server API.*?</td><td.*?>(.*?)</td>#msi' : '#\nServer API.*?=>(.*?)\n#msi';
        $api = preg_match($pattern, $buffer, $matches)===1 ? trim($matches[1]) : null;

        $pattern = preg_match('#</td>#msi', $buffer)===1 ? '#>System.*?</td><td.*?>(.*?)</td>#msi' : '#\nSystem.*?=>(.*?)\n#msi';
        $sys = preg_match($pattern, $buffer, $matches)===1 ? trim($matches[1]) : null;


        // build results array PHP Handler
        $results[] = array(
            'title'  => $this->_('Handler'),
            'value'  => $api,
            'status' => self::$ok,
            'action' => '',
        );


        // build results array PHP system info
        $results[] = array(
            'title'  => $this->_('System Information'),
            'value'  => $sys,
            'status' => self::$ok,
            'action' => '',
        );

        return $results;
    }


    /**
     * Returns a diagnostic array about the current time settings.
     */
    protected function getTimeDiagnostics()
    {
        $results[] = array(
            'title'  => $this->_('Timezone'),
            'value'  => $this->wire->config->timezone,
            'status' => self::$ok,
            'action' => '',
        );

        return $results;
    }


    /**
     * Reads basic FS parameters for the given file or directory.
     */
    protected function getFileSystemAttribs($name, $pathspec)
    {
        $fs_info = array(
            'name'   => $name,
            'path'   => $pathspec,
            'exists' => file_exists($pathspec),
            'isfile' => false,
            'islink' => false,
            'isdir'  => false,
            'read'   => false,
            'write'  => false,
            'exec'   => false,
            'perms'  => false,
        );

        if ($fs_info['exists']) {
            $fs_info['isfile'] = is_file($pathspec);
            $fs_info['islink'] = is_link($pathspec);
            $fs_info['isdir']  = is_dir($pathspec);
            $fs_info['read']   = is_readable($pathspec);
            $fs_info['write']  = is_writable($pathspec);
            $fs_info['exec']   = is_executable($pathspec);
            $fs_info['perms']  = fileperms($pathspec);
        }

        return $fs_info;
    }


    /**
     * Creates a text description from the given file information.
     */
    public function describeFSInfo($info)
    {
        $out = array();

        if ($info['exists']) {
            $out[] = $this->_('Exists');

            if ($info['read']) {
                $out[] = $this->_('is readable');
            } else {
                $out[] = $this->_('is not readable');
            }

            if ($info['write']) {
                $out[] = $this->_('is writable');
            } else {
                $out[] = $this->_('is not writable');
            }

            $out[] = substr(sprintf('%o', $info['perms']), -4);
        } else {
            $out[] = $this->_('Does not exist.');
        }

        return implode(', ', $out);
    }


    /**
     * Returns a diagnostic array about the webserver.
     *
     * For Apache, this also checks if the .htaccess file is in the right place and is readable by the webserver.
     */
    protected function getWebserverDiagnostics()
    {
        $results[] = array(
            'title'  => $this->_('Webserver'),
            'value'  => $this->server_software,
            'status' => self::$ok,
            'action' => '',
        );

        if ($this->is_apache) {
            if (is_callable('apache_get_modules')) {
                $apache_modules = apache_get_modules();

                $rewrite_ok = in_array('mod_rewrite', $apache_modules);
                $results[] = array(
                    'title'  => $this->_('Apache mod_rewrite'),
                    'value'  => $rewrite_ok ? $this->_('Installed') :
                                              $this->_('Not installed'),
                    'status' => $rewrite_ok ? self::$ok : self::$fail,
                    'action' => $rewrite_ok ? '' : $this->_('Install mod_rewrite, it\'s currently not available to Apache.'),
                );
            }

            $ht_info = $this->getFileSystemAttribs('.htaccess', $this->wire->config->paths->root.'/.htaccess');
            $httext_info = $this->getFileSystemAttribs('htaccess.txt', $this->wire->config->paths->root.'/htaccess.txt');

            $ht_ok        = $ht_info['exists'] && $ht_info['read'];
            $ht_write     = $ht_info['write'];
            $ht_status    = self::$fail;
            if ($ht_ok) {
                if ($ht_write) {
                    $ht_status = self::$warn;
                } else {
                    $ht_status = self::$ok;
                }
            }
            $ht_mv_needed = $httext_info['exists'] && !$ht_info['exists'];

            if ($httext_info['exists']) {
                // Diagnostics for the htaccess.txt file...
                $results[] = array(
                    'title'  => 'htaccess.txt',
                    'value'  => $this->describeFSInfo($httext_info),
                    'status' => ($ht_mv_needed || $httext_info['exists']) ? self::$fail : self::$ok,
                    'action' => $ht_mv_needed ? $this->_('Rename htaccess.txt to .htaccess') :
                    $httext_info['exists'] ? $this->_('Delete htaccess.txt') : '',
                    );
            }

            // Diagnostics for the .htaccess file...
            $results[] = array(
                'title'  => $this->_('.htaccess file'),
                'value'  => $this->describeFSInfo($ht_info),
                'status' => $ht_status,
                'action' => $ht_ok && !$ht_write ? '' : $this->_('.htaccess must exist, must be readable, should <strong>not</strong> be writable.'),
            );
        }

        return $results;
    }


    /**
     * TODO extend these checks to cover other users in the system, not just the webserver user. For example, if a dir
     * is 777 it's probably too wide open and at least needs a warning generated.
     */
    protected function getFilesystemDiagnostics()
    {
        $install_file = $this->getFileSystemAttribs($this->_('Installation file'),        $this->wire->config->paths->root.'/install.php');
        $install_dir  = $this->getFileSystemAttribs($this->_('Installation directory'),   $this->wire->config->paths->root.'/site/install/');
        $site_def_dir = $this->getFileSystemAttribs($this->_('/site-default/ directory'), $this->wire->config->paths->root.'/site-default/');

        $root_info    = $this->getFileSystemAttribs($this->_('Root directory'),    $this->wire->config->paths->root);
        $asset_info   = $this->getFileSystemAttribs($this->_('Assets directory'),  $this->wire->config->paths->assets);
        $cache_info   = $this->getFileSystemAttribs($this->_('Cache directory'),   $this->wire->config->paths->cache);
        $sess_info    = $this->getFileSystemAttribs($this->_('Session directory'), $this->wire->config->paths->sessions);
        $site_info    = $this->getFileSystemAttribs($this->_('Site directory'),    $this->wire->config->paths->site);

        $inst_file_ok = !$install_file['exists'];
        $inst_dir_ok  = !$install_dir['exists'];
        $root_ok      =  $root_info['exists']  &&  $root_info['read']  && !$root_info['write'];
        $assets_ok    =  $asset_info['exists'] &&  $asset_info['read'] &&  $asset_info['write'];
        $cache_ok     =  $cache_info['exists'] &&  $cache_info['read'] &&  $cache_info['write'];
        $sessions_ok  =  $sess_info['exists']  &&  $sess_info['read']  &&  $sess_info['write'];

        $results[] = array(
            'title'  => $root_info['name'],
            'value'  => $this->describeFSInfo($root_info),
            'status' => ($root_ok) ? self::$ok : self::$fail,
            'action' => ($root_ok) ? '' : $this->_('Folder should not be writable for webserver user.'),
        );

        $results[] = array(
            'title'  => $install_file['name'],
            'value'  => $this->describeFSInfo($install_file),
            'status' => ($inst_file_ok) ? self::$ok : self::$fail,
            'action' => ($inst_file_ok) ? '' : $this->_('Delete the file "install.php".'),
        );

        $results[] = array(
            'title'  => $install_dir['name'],
            'value'  => $this->describeFSInfo($install_dir),
            'status' => ($inst_dir_ok) ? self::$ok : self::$fail,
            'action' => ($inst_dir_ok) ? '' : $this->_('Delete the "/site/install/" directory.'),
        );

        if ($site_def_dir['exists']) {
            $results[] = array(
                'title'  => $site_def_dir['name'],
                'value'  => $this->describeFSInfo($site_def_dir),
                'status' => ($inst_dir_ok) ? self::$ok : self::$fail,
                'action' => ($inst_dir_ok) ? '' : (($site_info['exists']) ? $this->_('Delete the "/site-default/" directory.') :
                                                                            $this->_('Installation should have renamed "/site-default/" to "/site/".')),
                );
        }

        $site_ok = $site_info['exists'] && $site_info['read'] && !$site_info['write'];
        $results[] = array(
            'title'  => $site_info['name'],
            'value'  => $this->describeFSInfo($site_info),
            'status' => ($site_ok) ? self::$ok : self::$fail,
            'action' => ($site_ok) ? '' : $this->_('Folder should not be writable for webserver user.'),
        );

        $results[] = array(
            'title'  => $asset_info['name'],
            'value'  => $this->describeFSInfo($asset_info),
            'status' => ($assets_ok) ? self::$ok : self::$fail,
            'action' => ($assets_ok) ? '' : $this->_('Folder should be writable for webserver user.'),
        );

        $results[] = array(
            'title'  => $cache_info['name'],
            'value'  => $this->describeFSInfo($cache_info),
            'status' => ($cache_ok) ? self::$ok : self::$fail,
            'action' => ($cache_ok) ? '' : $this->_('Folder should be writable for webserver user.'),
        );

        $results[] = array(
            'title'  => $sess_info['name'],
            'value'  => $this->describeFSInfo($sess_info),
            'status' => ($sessions_ok) ? self::$ok : self::$fail,
            'action' => ($sessions_ok) ? '' : $this->_('Folder should be writable for webserver user.'),
        );


        return $results;
    }


    /**
     * Capitialise the initial character of the given string.
     */
    public function initCap($string)
    {
        return strtoupper($string[0]) . substr($string, 1);
    }


    protected function getImagesDiagnostics()
    {
        if(!function_exists('gd_info')) {
            $results[] = array(
                'title'  => $this->_('GD library'),
                'value'  => $ver,
                'status' => self::$fail,
                'action' => $this->_('There seems to be no GD-library installed!')
            );
        } else {
            $gd  = gd_info();
            $ver = isset($gd['GD Version']) ? $gd['GD Version'] : $this->_('Version-Info not available');
            $jpg = isset($gd['JPEG Support']) ? $gd['JPEG Support'] : false;
            $png = isset($gd['PNG Support']) ? $gd['PNG Support'] : false;
            $gif = isset($gd['GIF Read Support']) && isset($gd['GIF Create Support']) ? $gd['GIF Create Support'] : false;
            $freetype = isset($gd['FreeType Support']) ? $gd['FreeType Support'] : false;

            // GD version
            $results[] = array(
                'title'  => $this->_('GD library'),
                'value'  => $this->initCap($ver),
                'status' => self::$ok,
                'action' => ''
            );

            // PHP with GD bug ?
            if((version_compare(PHP_VERSION, '5.5.8', '>') && version_compare(PHP_VERSION, '5.5.11', '<'))) {
                if(version_compare($this->config->version, '2.4.1', '<')) {
                    $results[] = array(
                        'title'  => $this->_('GD library Bug'),
                        'value'  => $this->_('Possible bug in GD-Version'),
                        'status' => self::$warn,  // @steve: or better use self::fail ?
                        'action' => $this->_('Bundled GD libraries in PHP versions 5.5.9 and 5.5.10 are known as buggy. You should update A) your PHP version to 5.5.11 or newer, or B) the ProcessWire version to 2.4.2 or newer')
                    );
                }
            }

            // GD supported types
            foreach(array('JPG', 'PNG', 'GIF', 'FreeType') as $v) {
                $name = $this->_(sprintf('GD %s Support', $v));
                $v = strtolower($v);
                $value = $$v ? $this->_('Supported') :
                                $this->_('Not supported');
                $status = $$v ? self::$ok : self::$fail;
                $results[] = array(
                    'title'  => $name,
                    'value'  => $value,
                    'status' => $status,
                    'action' => ''
                );
            }
        }


        // check if we can read exif data

        $res = function_exists('exif_read_data');
        $action = $res ? '' : $this->_("Not needed for PW core, might be needed by third party modules.");
        $results[] = array(
            'title'  => $this->_('Exif read data'),
            'value'  => $res ? $this->_('Available') :
                               $this->_('Not available'),
            'status' => $res ? self::$ok : self::$warn,
            'action' => $action
        );


        // check if Imagick is supported

        if(!class_exists('Imagick')) {
            $results[] = array(
                'title'  => $this->_('Imagick Extension'),
                'value'  => $this->_('Not available'),
                'status' => self::$warn,
                'action' => $this->_('Not needed for PW core, might be needed by third party modules.')
            );
        } else {
            if(self::isDisabled('phpinfo')) {
                $results[] = array(
                    'title'  => $this->_('Imagick Extension'),
                    'value'  => $this->_('Available'),
                    'status' => self::$warn,
                    'action' => $this->_('Odd, retrieving phpinfo on your server is disabled! We cannot get further informations here.')
                );
            } else {
                $results[] = array(
                    'title'  => $this->_('Imagick Extension'),
                    'value'  => $this->_('Available'),
                    'status' => self::$ok,
                    'action' => ''
                );
                ob_start();
                phpinfo();
                $buffer = ob_get_clean();
                $pattern = '/>imagick<.*?<table.*?(<tr>.*?<\/table>)/msi';
                preg_match($pattern, $buffer, $matches);
                if(isset($matches[1])) {
                    $buf = trim(str_replace('</table>', '', $matches[1]));
                    $a = explode("\n", strip_tags(str_replace(array("\r\n", "\r", '</td><td'), array("\n", "\n", '</td>###<td'), $buf)));
                    $info = array();
                    foreach($a as $line) {
                        if(preg_match('/ImageMagick supported formats/i', $line)) continue;
                        $tmp = explode('###', $line);
                        $k = trim($tmp[0], ': ');
                        $v = str_replace(' http://www.imagemagick.org', '', trim($tmp[1]));
                        #$results['images'][] = array(
                        $results[] = array(
                            'title'  => $k,
                            'value'  => $v,
                            'status' => self::$ok,
                            'action' => ''
                        );
                    }
                }
            }
        }


        return $results;
    }


    /**
     * To extend the collected information, just add a new method call to the list of arrays in this array merge.
     * Each method must return an array of results (numerically keyed) and each result will be an array with four string
     * keys... 'title', 'value', 'status' and 'action'.
     */
    public function ___collectDiagnostics()
    {
        $results = array(
            $this->_('PHP Diagnostics...')            => $this->getPHPDiagnostics(),
            $this->_('Webserver Diagnostics...')      => $this->getWebserverDiagnostics(),
            $this->_('Filesystem Diagnostics...')     => $this->getFilesystemDiagnostics(),
            $this->_('Image Handling Diagnostics...') => $this->getImagesDiagnostics(),
            $this->_('Date/Time Diagnostics...')      => $this->getTimeDiagnostics()
        );

        return $results;
    }


    /**
     * Applies the selected verbosity to filter out unwanted diagnostic results.
     */
    public function filterDiagnostics(array $results)
    {
        if (self::HIGH_VERBOSITY === self::$verbosity) {
            return $results;
        }

        $filtered = array();
        foreach ($results as $caption => &$section_results) {
            $section_filtered = array();
            foreach ($section_results as $k => $diagnosis) {
                $status = $diagnosis['status'];

                if (
                   ($status === self::$ok) ||
                   ($status === self::$warn && self::LOW_VERBOSITY === self::$verbosity)
                ) {
                    continue;
                }

                $section_filtered[] = $diagnosis;
            }

            if (count($section_filtered)) {
                $filtered[$caption] = $section_filtered;
            }
        }

        return $filtered;
    }

    public function ___execute()
    {
        $this->setFuel('processHeadline', $this->_('System Diagnostics'));

        $out = "<p class='description'>". $this->_("Results of scanning your system...") . "</p>";

        $results = $this->collectDiagnostics();

        /**
         * Apply verbosity rules to collected information...
         */
        $results = $this->filterDiagnostics($results);

        foreach ($results as $caption => $section_results) {

            $out .= "\n<table class='DiagnosticsTable'>";
            $out .= "\n<caption>" . htmlspecialchars($caption, ENT_QUOTES | ENT_HTML5, 'UTF-8') . "</caption>";
            $out .= "\n<thead><tr>";
            $out .= "\n<th class='title'>".$this->_('Attribute')."</th>";
            $out .= "\n<th class='value'>".$this->_('Value')."</th>";
            $out .= "\n<th class='status'>".$this->_('Status')."</th>";
            $out .= "\n<th class='action'>".$this->_('Notes / Corrective Actions')."</th>";
            $out .= "\n</tr></thead>";
            $out .= "\n<tbody>";

            foreach ($section_results as $k => $row) {
                $class = 'ok';
                switch ($row['status']) {
                case self::$fail :
                    $class = 'failure';
                    break;
                case self::$warn :
                    $class = 'warning';
                    break;
                default :
                    $class = 'ok';
                }

                $out .= "\n<tr>";
                $out .= "\n<td>" . $row['title'] . "</td>";
                $out .= "\n<td>" . $row['value'] . "</td>";
                $out .= "\n<td class='status'><div class='$class'>" . $row['status'] . "</div></td>";
                $out .= "\n<td>" . $row['action'] . "</td>";
                $out .= "\n</tr>";

            }
            $out .= "\n</tbody></table>";
        }
        return $out;
    }


    public function ___install()
    {
        $p = new Page();
        $p->template = $this->templates->get("admin");
        $p->parent = $this->pages->get("template=admin, name=setup");
        $p->title = $this->_('Diagnostics');
        $p->name  = __CLASS__;
        $p->process = $this;
        $p->save();
    }


    public function ___uninstall()
    {
        $p = $this->pages->get('template=admin, name=' . __CLASS__);
        if ($p->id > 0) {
            $p->delete();
        }
    }
}

// eof
